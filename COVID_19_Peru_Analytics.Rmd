---
title: "COVID-19 Outbreak Analytics - Peru"
author: "Alexis Roldan"
date: "`r format(Sys.time(), '%d %B %Y')`"
mail: "argos2416@gmail.com"
linkedin: "alexis-roldan-ds"
twitter: "wizard2416"
github: "wizard2416"
logo: "peru-logo.png"
output:
  EpuArgs::EpuArgs:
    toc: TRUE
    number_sections: FALSE
  html_document: 
    fig_height: 7
    fig_width: 10
    toc: yes
    toc_float:
      collapsed: no
      smooth_scroll: yes
  pdf_document:
    toc: yes
editor_options:
  chunk_output_type: console
---

<!-- To set up all chunks to cache = true as default -->
```{r setup, include=FALSE}
library(knitr)
library(rgl)
knit_hooks$set(webgl = hook_webgl)
knitr::opts_chunk$set(cache=FALSE, message = FALSE, warning = FALSE,
                      fig.align = "center")
```

<br><br>

> **Before we begin please note anything bolded is either a finding or an important comment**

# Introduction
<br>
This blog illustrates the use of R to analyze COVID-19 Outbreak in Peru by applying different algorithms in an attempt to gauge the spread of the virus and success of public health containment efforts in reducing the speed and degree of spread.

For this analysis, I'm laboring [Tim Churche's blog](https://timchurches.github.io/blog/posts/2020-02-18-analysing-covid-19-2019-ncov-outbreak-data-with-r-part-1/) which containings a detailed analysis of COVID-19 data for China.

This analysis is for **informational purposes only** and should not be relied upon for to inform governmental or health care policy.

# Data sources
<br>
Data utilized for this analysis comes from [Coronavirus wiki](https://en.wikipedia.org/wiki/Timeline_of_the_2019â€“20_Wuhan_coronavirus_outbreak), Peruvian Ministry of Health [MINSA](https://www.gob.pe/minsa/), [Outbreak Dashboard](https://chschoenenberger.shinyapps.io/covid19_dashboard/) and [nCOV19 package](https://github.com/GuangchuangYu/nCov2019). The use of these pages through web scraping can be challenging, however, because the format of the tables in which the data appears changes many times per day. 

## Data limitations
<br>
The biggest problem with these analyses is that they are **not** based on data tabulated by **date of onset** (of symptoms), but rather on data tabulated by **date of reporting**, or perhaps date of confirmation by lab test. We understand that **lab results from molecular tests can take up to 7 days to be published** while **lab results from serological tests are not reliable due that test looks for antibodies within the blood stream which are usually developed from 7 to 30 days after contracting the virus**.

If lab testing and reporting is swift and the lag is uniform, then the date of reporting or confirmation will lag consistently and only slightly behind the date of onset. Sadly that's not usually the case, there are tipacally variable delays in lab confirmation and/or reporting, leading to backlogs of cases being reported all at once (known as a "data dump" by outbreak epidemiologists). This is very unfortunate, and it frustrates efforts to properly assess outbreak trajectories and effectiveness of intervention strategies. One solution would be for authorities to provide line-listings of all cases, including their date of reporting **and** their date of onset of symptoms, even if only presumptive dates are provided (and missing dates of onset can be imputed, in any case).

The effect of the unavoidable (because that's all that is available) use of data tabulated by date of reporting here (and just about everywhere else) means that reproduction numbers and related measures of infectiousness may be inflated, particularly at first. Nonetheless, the methods illustrated here show the potential utility of epidemic trajectory analysis -- but that utility would be **so much greater** if health authorities published data tabulated by date of onset, or better, line-listings that include date of onset. It would be very easy for them to do that.

## Data Update
<br>
This initial analysis is meant to visualize and forecast **COVID-19 spread in Peru**.

**Peru COVID-19 dataset was updated on:** `r format(Sys.Date(),'%d%b%y')`

# Analysis methods
<br>
The analysis presented here primarily uses R packages developed and published by the [**R Epidemics Consortium**](https://www.repidemicsconsortium.org) (RECON).

The functions provided by the **RECON**  [`incidence`](https://www.repidemicsconsortium.org/incidence/) package are used to fit log-linear models to the growth and decay phases of the outbreak in Peru, and the decay phase model is used to very approximately predict when local transmission will be extinguished there. 

I also utilize [`earlyR`](https://www.repidemicsconsortium.org/earlyR/) and `EpiEstim` packages, which are also published by **RECON**. In particular the `get_R()` function in `earlyR` calculates a maximum-likelihood estimate (from a distribution of likelihoods for the reproduction number) as well as calculating $\lambda$, which is a relative measure of the current "force of infection":

$$ \lambda = \sum_{s=1}^{t-1} {y_{s} w (t - s)} $$


where $w()$ is the probability mass function (PMF) of the serial interval, and $y_s$ is the incidence at time $s$.

The resulting $\lambda$ "force of infection" plot indicates the daily effective infectiousness (subject to public health controls), with a projection of the diminution of the force of infection if no further cases are observed. The last date of observed data is indicated by the vertical blue dashed line. New cases are shown in a cumulative manner as black dots. It is a sign that the outbreak is being brought under control if $\lambda$, as indicated by the orange bars, is falling prior to or at the date of last observation (as indicated by the vertical blue line). Note that left of the vertical blue line the $\lambda$ values are projections, valid only in **no further cases are observed**. As such, the plot is a bit confusing, but it is nonetheless useful if interpreted with this explanation in mind. The **RECON** packages are all open-source, and easier-to-interpret plots of $\lambda$ could readily be constructed.

The critical parameter for these calculation is the distribution of _serial intervals_ (SI), which is the time between the date of onset of symptoms for a case and the dates of onsets for any secondary cases that case gives rise to. Typically a discrete $\gamma$ distribution for these _serial intervals_ is assumed, parameterised by a mean and standard deviation, although more complex distributions are probably more realistic. 

For the estimation of the force of infection $\lambda$, for the _serial interval_ we'll use a discrete $\gamma$ distribution with a mean of 5.0 days and a standard deviation of 3.4.

----

# Data Understanding
<br>
After having an understanding on what is our business problem, __initial datasets__ are loaded for data preparation and exploration prior model development.

## Libraries & Functions
<br>
Let's begin by loading the libraries and functions that will be used for this analysis:

```{r Libraries, echo=FALSE}

load.libraries <- c('plyr', 'dplyr','data.table', 'tibble',
                    'stringr', 'stringi','forecast', 'tidyverse', 'broom','gt',
                    'caret','zoo','plotly','DT','tidyr', 'rvest', 'hrbrthemes',
                    'inspectdf','DataExplorer','ggplot2','tsoutliers', 'ggthemes',
                    'dlm','PerformanceAnalytics', 'projections', 'earlyR', 
                    'ggdendro','rgdal','tsibble', 'EpiEstim','epitrix',
                    'distcrete','shadowtext','nCov2019','magrittr','incidence')

install.lib <- load.libraries[!load.libraries %in% installed.packages()]
for(libs in install.lib) install.packages(libs, dependences = TRUE)
sapply(load.libraries, require, character = TRUE)

library("corrplot")
library("RColorBrewer")
library(lubridate)
library(deSolve)
library(projections)
library(shadowtext)
library(covid19.analytics)

```


## Data Collection
<br>
Raw data for each Peru COVID-19 dataset are loaded.

<!-- ALt+Ctrl+I is the shorcut to insert R code -->
```{r read Data, echo=FALSE, results = 'hide'}

#load raw data
## Load data
load("rda/COVID_19_Peru_Raw.rda")

load("rda/COVID_19_Peru_Raw_Inc2day.rda")

w <- load_nCov2019(lang = 'en')

tsc <- covid19.data(case = "ts-confirmed")
tsa <- covid19.data(case = "ts-ALL")

```

## Summary
<br>
The COVID-19 dataset (COVID_19_Peru_Raw) has `r dim(COVID_19_Peru_Raw)[1]` rows and `r dim(COVID_19_Peru_Raw)[2]` columns while COVID-19 dataset case increase every 2 days has `r dim(COVID_19_Peru_Raw_Inc2day)[1]` rows and `r dim(COVID_19_Peru_Raw_Inc2day)[2]` columns
  
# Worldwide Analytics
<br>
Please see below for **COVID-19 Outbreak Worldwide Analytics** updated on `r format(max(w['global']$time),'%d%b%y')`.

## Outbreak trend since 100th cases
<br>
Here we observe Worldwide Outbreak trend after the 100th reported possitive case: 

```{r Worldwide Analytics, message=FALSE, warning=FALSE, tidy=TRUE, echo=FALSE}

df <- w['global']
d <- subset(df,time == time(w))
t10 <- d[order(d$cum_confirm,decreasing = T),]$country[1:25]

ww <- w['global'] %>% 
  as_tibble %>%
  rename(possitive_cased_confirmed = cum_confirm) %>%
  filter(possitive_cased_confirmed > 100 & !country == 'China') %>%
  group_by(country) %>%
  mutate(days_since_100th_case = as.numeric(time - min(time))) %>%
  ungroup 

ww <- ww[which(ww$country %in% t10),]  

breaks=c(100, 200, 500, 1000, 2000, 5000, 10000, 20000, 50000, 100000, 200000, 500000, 1000000)

p <- ggplot(ww, aes(days_since_100th_case, 
                    possitive_cased_confirmed, 
                    color = country,
                    group = 1,
                    text = paste('Country:', country,
                                 '<br># possitive case confirmed: ', formatC(possitive_cased_confirmed, big.mark=","),
                                 '<br># days after 100th case: ', days_since_100th_case ))) +
  # geom_smooth(method='lm', aes(group=1),
  #             data = . %>% filter(!country %in% c("Japan", "Singapore")), 
  #             color='grey10', linetype='dashed') +
  geom_line(size = 0.8) +
  geom_point(pch = 21, size = 1) +
  scale_y_log10(expand = expansion(add = c(0,0.1)), 
                breaks = breaks, labels = breaks) +
  scale_x_continuous(expand = expansion(add = c(0,1))) +
  theme_minimal(base_size = 14) +
  theme(
    panel.grid.minor = element_blank(),
    legend.position = "right",
    plot.margin = ggplot2::margin(3,15,3,3,"mm")
  ) +
  coord_cartesian(clip = "off") +
  geom_shadowtext(aes(label = paste0(" ",country)), hjust=0, vjust = 0, 
                  data = . %>% 
                    group_by(country) %>% 
                    top_n(1, days_since_100th_case), 
                  bg.color = "white") +
  labs(x = "Number of days since 100th case", 
       y = "# Possitive cases", 
       title = "Daily Lab-Confirmed Cases - Top 25 Countries")

ggplotly(p, tooltip = c("text"))

```


## Geographic Cumulative Cases
<br>
Below we find a geographic heatmap based on possitive confirmed cases up to date:

```{r Geomap, message=FALSE, warning=FALSE, tidy=TRUE, echo=FALSE}

library('maps')
plot(w, palette = 'Blues')

```

## Epidemic Heatmap for top 25 countries on the last 7 days
<br>
Heatmap of epidemic situation around the world in the last 7 days (log scale) for top 25 countries with higher number of possitive cases.


```{r Epidemic Heatmap, message=FALSE, warning=FALSE, tidy=TRUE, echo=FALSE}

df <- df[which(df$country %in% t10),]  

d<-df
max_time <- max(d$time)
min_time <- max_time - 7

d <- na.omit(d[d$time >= min_time & d$time <= max_time,])

dd <- d[d$time == max(d$time, na.rm = TRUE),]

d$country <- factor(d$country, 
  levels=unique(dd$country[order(dd$cum_confirm)]))

breaks = c(10, 100, 1000, 10000)

p<-ggplot(d, aes(time, country)) + 
  geom_tile(aes(fill = cum_confirm), color = 'black') + 
  scale_fill_viridis_c(trans = 'log', breaks = breaks, 
  labels = breaks) + 
  xlab(NULL) + ylab(NULL) +
  scale_x_date(date_labels = "%Y-%m-%d") +
  ggtitle("Daily cumulatve cases for last 7 days in log scale (Top 25 countries)") + 
  theme_minimal()

ggplotly(p)

```

# Peru Analytics

## Exploratory Data Analysis (EDA)
<br>
After raw data is loaded, I proceed to perform EDA on dataset.

### Data Cleaning
<br>
For this step, I perform a data cleaning if needed.

```{r Data cleaning, echo=FALSE}

introduce(COVID_19_Peru_Raw)

introduce(COVID_19_Peru_Raw_Inc2day)

```


### Daily cumulative incidence
<br>
First, let's look at the daily cumulative number of incident, lab-confirmed cases for Lima, for all the other provinces combined, and for all of Peru. 

```{r Peru_Cumulative_Incidence, message=FALSE, warning=FALSE, tidy=TRUE, echo=FALSE}

COVID_19_Peru_Raw$Date <- as.Date(COVID_19_Peru_Raw$Date, format = "dd/MM/YY")
COVID_19_Peru_Raw_Inc2day$Date <- as.Date(COVID_19_Peru_Raw_Inc2day$Date, format = "dd/MM/YY")

Peru_Daily_Incident <- COVID_19_Peru_Raw %>%
  pivot_longer(-Date, names_to="province",
                 values_to = "incident_cases") %>%
  filter(province %in% c("Lima_cases_increase", 
                         "Other_province_cases_increase", "Peru_cases_increase")) %>%
  mutate(province=ordered(province, c("Lima_cases_increase", 
                         "Other_province_cases_increase", "Peru_cases_increase")))

Peru_Cumulative_Incidence <- Peru_Daily_Incident %>%
  group_by(province) %>%
  arrange(Date) %>%
  tidyr::replace_na(list(incident_cases = 0)) %>%
  mutate(cumulative_incident_cases = cumsum(incident_cases)) %>%
  mutate(cumulative_incident_cases = ifelse(cumulative_incident_cases == 0,
                                            NA,
                                            cumulative_incident_cases)) 

# Plot graph
a<- Peru_Cumulative_Incidence %>%
  ggplot(aes(x = Date, y=cumulative_incident_cases)) + geom_point(color = "darkblue") + geom_line() +
    scale_x_date(date_breaks="7 days", date_labels = "%d %b") +
    facet_grid(province ~., scales="free_y") + labs(y="Daily cumulative incidence",
                                   title="Lab-confirmed possitive cases of COVID-19 in Peru",
                                   caption="Note: varying y-axis scales") +
  theme(legend.position = "none", 
          strip.text.y = element_text(size=11)) + theme_bw()

ggplotly(a)
```

The initial increases for Lima and the balance of the other provinces, and for all of Peru look to be approximately sigmoidal, as is expected for epidemic spread. Let's plot them on a logarithmic _y_ axis. We would expect to see a linear increase on a log scale if the epidemic curve is indeed exponential.

```{r log_cumulative_incidence, message=FALSE, warning=FALSE, tidy=TRUE, echo=FALSE}

b <- Peru_Cumulative_Incidence %>%
  ggplot(aes(x=Date, y=cumulative_incident_cases)) + geom_point(color = "darkblue") + geom_line() +
    scale_y_log10() +
    scale_x_date(date_breaks="7 days", date_labels = "%d %b") +
    facet_grid(province ~., scales="free_y") + labs(y="Daily cumulative incidence (log10)",
                                   title="Lab-confirmed possitive cases of COVID-19 in Peru",
                                   caption="Note: varying y-axis scales") +
    theme(legend.position = "none", 
          strip.text.y = element_text(size=11)) + theme_bw() 

ggplotly(b)
```

One could convince oneself that log-linearity is present.

### Daily incremental incidence
<br>
Let's also look at the daily incremental incidence. This is more informative, and is known in outbreak epidemiological parlance as the _epidemic curve_. It is traditionally visualised as a bar chart, which emphasises missing data more than a line chart, even one with points as well. We'll adhere to epidemiological tradition.

```{r Peru_Daily_Incident, message=FALSE, warning=FALSE, tidy=TRUE, echo=FALSE}

c <- Peru_Daily_Incident %>%
  ggplot(aes(x=Date, y=incident_cases))  + # geom_point() + geom_line() +
    geom_bar(stat="identity", fill = "darkblue") + 
    scale_x_date(date_breaks="7 days", date_labels = "%d %b") +
    facet_grid(province ~., scales="free_y") + labs(y="Daily incremental incidence",
                                   title="Lab-confirmed possitive cases of COVID-19 in Peru",
                                   caption="Note: varying y-axis scales")  +
    theme(legend.position = "none", 
          strip.text.y = element_text(size=11)) + theme_bw()

ggplotly(c)

x <- COVID_19_Peru_Raw %>%
  ggplot(aes(x=Date, y=increase_index_case_percent_Peru,
             text = paste('Date: ', Date,
                          '<br>Percentage (%):', round(increase_index_case_percent_Peru*100,1))))  + # geom_point() + geom_line() +
    geom_bar(stat="identity", 
             fill = ifelse(COVID_19_Peru_Raw$increase_index_case_percent_Peru < 0, "darkred",
                                            "darkblue")) + 
    scale_x_date(date_breaks="7 days", date_labels = "%d %b") +
    labs(y="% Index of possitive cases per day",
         title="Index for Lab-confirmed possitive cases of COVID-19 in Peru")  +
    theme(legend.position = "none", 
          strip.text.y = element_text(size=11)) + theme_bw() +
  scale_y_continuous(labels = scales::percent)

ggplotly(x,tooltip = c("text"))


plot_ly(x = ~COVID_19_Peru_Raw$Date, 
        y = ~COVID_19_Peru_Raw$percent_cases_increase_per_day_Peru,
        type = "scatter",
        mode = "markers+lines",
        line = list(color = "blue"),
        marker = list(color = "black"),
        hoverinfo = 'text',
         text = ~paste('</br> Date: ', COVID_19_Peru_Raw$Date, 
                       '</br> Increase: ', paste(round(COVID_19_Peru_Raw$percent_cases_increase_per_day_Peru*100,1),
                                                 "%", sep="") )
        ) %>%
  
  layout(title = "Percentage of Lab-confirmed possitive cases of COVID-19 in Peru
         (Every 1 day)",
     xaxis = list(title = "Date",
                  date_breaks="7 days", date_labels = "%d %b"),
                  #range = c(118,195)),
     yaxis = list(title = "Incremental incidence every 1 day (%)",
                  tickformat = "%")
                  #range = c(10,30))
     )

# 
# z <- COVID_19_Peru_Raw %>%
#   ggplot(aes(x = Date, 
#              y = percent_cases_increase_per_day_Peru,
#              text = paste('Date: ', Date,
#                           '<br>Percentage (%):', round(percent_cases_increase_per_day_Peru*100,1)))) +
#   geom_point() + geom_line() +
#   # geom_bar(stat="identity", fill = "darkblue") + 
#   scale_x_date(date_breaks="7 days", date_labels = "%d %b") +
#   labs(y="Incremental incidence every 1 day (%)",
#        title="Percentage of Lab-confirmed possitive cases of COVID-19 in Peru every 1 day")  +
#   theme(legend.position = "none", 
#         strip.text.y = element_text(size=11)) + theme_bw() +
#   scale_y_continuous(labels = scales::percent) 
# 
# ggplotly(z, tooltip = c("text"))


```

At the time of writing (`r format(Sys.Date(),'%d%b%y')`), it looks like incidence has yet to plateaued in Peru.

### Daily cumulative and incremental deaths in lab-confirmed cases
<br>
Now let's look the daily (incremental) number of deaths in lab-confirmed cases for all provinces in Peru combined. 

```{r cumulative_deaths, message=FALSE, warning=FALSE, tidy=TRUE, echo=FALSE}

# Change the 0 on deaths to NA

COVID_19_Peru_Raw <- COVID_19_Peru_Raw %>% 
  mutate(Deaths_Total = ifelse(Deaths_Total == 0,
                               NA,
                               Deaths_Total)) %>%
  mutate(Death_Daily = ifelse(Death_Daily == 0 & Date < ymd("2020-03-19"),
                               NA,
                               Death_Daily)) %>% 
  mutate(percent_death_increase_per_day = ifelse(percent_death_increase_per_day == 0 & 
                                                   Date < ymd("2020-03-19"), 
                                                 NA,
                                                 percent_death_increase_per_day))  %>% 
  mutate(`increase_index_death_percent)Peru` = ifelse(`increase_index_death_percent)Peru` == 0 & 
                                                        Date < ymd("2020-03-19"), 
                                                 NA,
                                                 `increase_index_death_percent)Peru`)) 


d <- COVID_19_Peru_Raw %>%
  ggplot(aes(x=Date, y=Deaths_Total)) +
  geom_bar(stat="identity", fill = "brown") + 
  scale_x_date(date_labels = "%d %b") +
  labs(y="Daily cumulative deaths",
       title="Cumulative deaths in lab-confirmed possitive cases of COVID-19 in Peru",
       caption="Note: varying y-axis scales") +
  theme(legend.position = "none", 
          strip.text.y = element_text(size=11)) + theme_bw()

ggplotly(d)

```

Let's also look at the daily incremental deaths in lab-confirmed cases.

```{r daily_deaths_plot, message=FALSE, warning=FALSE, tidy=TRUE, echo=FALSE}

e <- COVID_19_Peru_Raw %>%
  ggplot(aes(x=Date, y=Death_Daily)) + 
  geom_bar(stat="identity", fill = "brown") + 
  scale_x_date(date_labels = "%d %b") +
    labs(y="Daily incremental deaths",
         title="Daily deaths in lab-confirmed possitive cases of COVID-19 in Peru",
         caption="Note: varying y-axis scales")  +
    theme(legend.position = "none", 
          strip.text.y = element_text(size=11)) + theme_bw()

ggplotly(e)

# y <- COVID_19_Peru_Raw %>%
#   # mutate(colorbars = ifelse(COVID_19_Peru_Raw$`increase_index_death_percent)Peru` > 0, 
#                             # "darkred", "darkblue")) %>%
#   ggplot(aes(x=Date, 
#              y=`increase_index_death_percent)Peru`,
#              text = paste('Date: ', Date,
#                           '<br>Percentage (%):', round(`increase_index_death_percent)Peru`*100,1)))) +
#   geom_bar(stat="identity", 
#            fill = ifelse(COVID_19_Peru_Raw$`increase_index_death_percent)Peru` < 0, "darkred",
#                          "darkblue")) + 
#   theme_bw() +
#   scale_x_date(date_breaks="7 days", date_labels = "%d %b") +
#   labs(y="% Index of deaths per day",
#        title="Percentage Index for Death Lab-confirmed possitive cases of COVID-19 in Peru")  +
#   theme(legend.position = "none") +
#   scale_y_continuous(labels = scales::percent)

# 
# y <- COVID_19_Peru_Raw %>%
#   ggplot(aes(x=Date, y=`increase_index_death_percent)Peru`,
#              fill = ifelse(`increase_index_death_percent)Peru` < 0, "darkred",
#                          "darkblue"),
#              text = paste('Date: ', Date,
#                           '<br>Percentage (%):', round(`increase_index_death_percent)Peru`*100,1)))) +
#     geom_bar(stat="identity") + 
#     scale_x_date(date_breaks="7 days", date_labels = "%d %b") +
#     labs(y="Incremental deaths every 1 day (%)",
#          title="Percentage of Deaths for COVID-19 in Peru every 1 day")  +
#     theme_bw() +
#     theme(legend.position = "none", 
#           strip.text.y = element_text(size=11))  +
#   scale_y_continuous(labels = scales::percent)
# 
# ggplotly(y, tooltip = c("text"))


COVID_19_Peru_Raw %>%
  filter(!is.na(`increase_index_death_percent)Peru`)) %>%
  mutate(coloroption = ifelse(`increase_index_death_percent)Peru` < 0, "darkred",
                         "darkblue")) %>%
  plot_ly(x = ~Date, 
          y = ~`increase_index_death_percent)Peru`,
          type = "bar",
          marker = list(color = ~coloroption)
          #mode = "markers+lines",
          # hoverinfo = 'text',
          # text = ~paste('</br> Date: ', ~Date, 
          #               '</br> Increase: ', ~`increase_index_death_percent)Peru` )
          ) %>%
  
  layout(title = "Index for deaths of COVID-19 in Peru",
     xaxis = list(title = "Date",
                  date_breaks="7 days", date_labels = "%d %b"),
                  #range = c(118,195)),
     yaxis = list(title = "% Index of deaths per day",
                  tickformat = "%")
                  #range = c(10,30))
     )

```
<br>
Clearly daily counts of deaths are continuing to rise despite the fact that the daily count of new cases is now falling. This is not surprising, given that it takes some time for cases to either recover or to die, and therefore the trend in deaths will necessarily lag behind any trend in daily incidence.

# Fitting an SIR model to the Peru data
<br>
On 4 February 2020, data science blogger _Learning Machines_ posted [this analysis](https://blog.ephorie.de/epidemiology-how-contagious-is-novel-coronavirus-2019-ncov) of the COVID-19 outbreak, in which he fitted the classic SIR (Susceptible-Infectious-Recovered) model to the incidence data for all of China. I'll use his explanation of how to fit this model using _R_ as based for this analysis.

The basic idea behind the SIR model of communicable disease outbreaks is that there are three groups (also called _compartments_) of people: those who are healthy but susceptible to the disease $S$, the infectious (and thus, infected) $I$ and people who have recovered $R$:

![Source: wikipedia](https://upload.wikimedia.org/wikipedia/commons/8/8a/SIR.PNG)

To model the dynamics of the outbreak we need three differential equations, to describe the rates of change in each group, parameterised by $\beta$ which controls the transition between $S$ and $I$ and $\gamma$ which controls the transition between $I$ and $R$:

$$\frac{dS}{dt} = - \frac{\beta I S}{N}$$

$$\frac{dI}{dt} = \frac{\beta I S}{N}- \gamma I$$

$$\frac{dR}{dt} = \gamma I$$

The first step is to express these differential equations as an _R_ function, which is easier than one might think -- the expressions in the code are just direct translations of the differential equations, with respect to time $t$ of course.

```{r SIR_function, echo=TRUE}
SIR <- function(time, state, parameters) {
  par <- as.list(c(state, parameters))
  with(par, {
    dS <- -beta * I * S / N
    dI <- beta * I * S / N - gamma * I
    dR <- gamma * I
    list(c(dS, dI, dR))
    })
}
```

To fit the model to the data we need two things: a solver for these differential equations and an optimiser to find the optimal values for our two unknown parameters, $\beta$ and $\gamma$. The function `ode()` (for _ordinary differential equations_) from the `deSolve` package for `R` makes solving the system of equations easy, and to find the optimal values for the parameters we wish to estimate, we can just use the `optim` function built into base _R_. Specifically what we need to do is minimise the sum of the squared differences between $I(t)$, which is the number of people in the infectious compartment $I$ at time $t$, and the corresponding number of cases as predicted by our model $\hat{I}(t)$. This quantity is known as the _residual sum of squares_ (RSS)^[It is also possible to fit SIR and related models by MLE.].

$$RSS(\beta, \gamma) = \sum_{t} \left( I(t)-\hat{I}(t) \right)^2$$

I now proceed to fit a model to the incidence data for all of Peru. We need a value $N$ for the initial uninfected population. Once again we'll scrape population data from a suitable wikipedia page.

```{r get_peru_population, message=FALSE, warning=FALSE, tidy=TRUE}


N <- 31237385
N_Lima <- 11209103
N <- as.numeric(N)

```

The approximate population of Peru in 2017 was `r format(N, big.mark=",")` people, according to [this wikipedia page](https://en.wikipedia.org/wiki/Peru). 

Next, we need to create a vector with the daily cumulative incidence for Peru, from 6th March when our daily incidence data starts, through to current date. We'll then compare the predicted incidence from the SIR model fitted to these data with the actual incidence since 6th March. We also need to initialise the values for $S$, $I$ and $R$. 

```{r incidence_vector, tidy=TRUE, echo=TRUE}
# put the daily cumulative incidence numbers for Peru from 
# 7th Mar to now into a vector called Infected
sir_start_date <- "2020-03-07"

Infected <- Peru_Cumulative_Incidence %>%
  filter(province == "Peru_cases_increase",
                     Date >= ymd("2020-03-07"),
                     Date <= ymd("2020-04-07")) %>%
              pull(cumulative_incident_cases)

# Create an incrementing Day vector the same length as our cases vector
Day <- 1:(length(Infected))

# now specify initial values for S, I and R
init <- c(S = N-Infected[1], I = Infected[1], R = 0)
```

Then we need to define a function to calculate the $RSS$, given a set of values for $\beta$ and $\gamma$.

```{r define_RSS_function, tidy=TRUE, echo=TRUE}
# define a function to calculate the residual sum of squares (RSS),
# passing in parameters beta and gamma that are to be optimised for the
# best fit to the incidence data
RSS <- function(parameters) {
  names(parameters) <- c("beta", "gamma")
  out <- ode(y = init, times = Day, func = SIR, parms = parameters)
  fit <- out[ , 3]
  sum((Infected - fit)^2)
}

```

Finally, we can fit the SIR model to our data by finding the values for $\beta$ and $\gamma$ that minimise the residual sum of squares between the observed cumulative incidence and the predicted cumulative incidence. We also need to check that our model has converged, as indicated by the message shown below:

```{r fit_SIR_model, tidy=TRUE, echo=TRUE}
# now find the values of beta and gamma that give the smallest RSS,
# which represents the best fit to the data. Start with values of 0.2 for each,
# and constrain them to the interval 0 to 1.0

# get a good starting condition
mod <- nls(Infected ~ a * exp(b * Day), 
           start = list(a = Infected[1],
                        b = log(Infected[2]/Infected[1])))

lower = c(0, 0)
upper = c(1, 1) 

optimsstart <- c(3,2)*coef(mod)[2]

set.seed(12)
Opt <- optim(optimsstart, RSS, method = "L-BFGS-B", 
             lower = lower, upper = upper,
             hessian = TRUE)

# check for convergence
Opt$message

sigest <- sqrt(Opt$value/(length(Infected)-1))
solve(1/(2*sigest^2)*Opt$hessian) 
```

Convergence is confirmed. Now we can examine the fitted values for $\beta$ and $\gamma$.

```{r SIR_model_fit_examine, echo=TRUE}
Opt_par <- setNames(Opt$par, c("beta", "gamma"))
Opt_par
```

Those values don't mean a lot, _per se_, but let's use them to get the fitted number of people infected to our SIR model for the dates up to **07Apr20**, which is the latest day that Peru published molecular test results without serological tests, and compare those fitted values with the observed data.

```{r SIR_model_plot_fitted_data, echo=FALSE, tidy=TRUE, message=FALSE}
# time in days for predictions, I will use 60 days forecast
t <- 1:as.integer(today()+60 - ymd(sir_start_date)) 
# get the fitted values from our SIR model
fitted_cumulative_incidence <- data.frame(ode(y = init, times = t, 
                                              func = SIR, parms = Opt_par))
# add a Date column and join the observed incidence data
fitted_cumulative_incidence <- fitted_cumulative_incidence %>%
  mutate(I = round(I)) %>%
  mutate(R = round(R)) %>%
  mutate(Date=ymd(sir_start_date) + days(t-1),
         province="Peru_cases_increase") %>%
  left_join(Peru_Cumulative_Incidence %>% 
              ungroup() %>%
              filter(province == "Peru_cases_increase") %>%
              select(Date, cumulative_incident_cases)) 
  
# plot the data
f <- fitted_cumulative_incidence %>%
  filter(Date <= ymd("2020-04-07")) %>%
  ggplot(aes(x=Date)) + geom_line(aes(y=I), colour="red") +
  geom_point(aes(y=cumulative_incident_cases), colour="blue") +
  labs(y="Cumulative incidence", 
       title="COVID-19 fitted vs observed cumulative incidence, Peru",
       subtitle="(red = fitted incidence from SIR model, blue = observed incidence)") + 
  theme_bw()

ggplotly(f)
```

That looks like a reasonably good fit to the observed cumulative incidence data, so we can now use our fitted model to calculate the  _basic reproduction number_ $R_{0}$ which gives the average number of susceptible people who are infected by each infectious person:

$$R_{0} = \frac{\beta}{\gamma}$$

That's very easy to calculate, and we get:

```{r SIR_model_R0, echo=FALSE, tidy=TRUE}
R0 <- setNames(Opt_par["beta"] / Opt_par["gamma"], "R0")
R0
```

An $R_{0}$ > 1.5 is consistent the values calculated by others for COVID-19, and is also consistent with the $R_{0}$ for SARS and MERS, which are similar diseases also cause by _coronavirus_.

## Using the SIR model for Peru to make predictions
<br>
An obvious next step is to use our fitted SIR model to make predictions about the future course of the outbreak. However, caution is required, because the SIR model assumes a fixed _reproduction number_, but if public health interventions have been implemented, such as quarantining of cases, contact tracing and isolation of those contacts, and general restrictions on social mixing, such as closing the country, then the _effective reproduction number_ $R_{e}$ will be dynamic and should fall as those interventions are progressively implemented, to values considerably less than the _basic reproduction number_ $R_{0}$, which reflects the behaviour of the virus at the beginning of an epidemic before any response has been implemented.

So let's use our SIR model, fitted to the first `r nrow(COVID_19_Peru_Raw)` days of data, to extrapolate out to the current date, and compare that against the observed values:

```{r SIR_model_plot_extrapolated, echo=FALSE, tidy=TRUE, message=FALSE, warning=FALSE}
g <- fitted_cumulative_incidence %>%
  mutate(I = round(I)) %>%
  ggplot(aes(x=Date)) + 
  geom_line(aes(y=I), colour="darkred") +
  geom_point(aes(y=cumulative_incident_cases), colour="blue") +
  scale_y_continuous(labels = scales::comma) +
  labs(y="Cumulative incidence", 
       title="COVID-19 Fitted vs Observed Cumulative Cases in Peru",
       subtitle="(red = fitted incidence from SIR model, blue = observed incidence)") +
  theme_bw()

ggplotly(g)
```

We can see that the actual incidence similar than that predicted by our model. The reason is that, even with public health interventions implemented by the Peruvian authorities, the $R_{e}$ of the COVID-19 in Peru hasn't been reduced by much. This is something that will need to be addressed ASAP.

When the $R_{e}$ falls below 1.0, the peak of the epidemic will have been reached and the outbreak will eventually die out.

## Using SIR model fitted for Peru to analyze outbreak
<br>
It is instructive to use our model fitted with up to date lab-confirmed cases data, to see what would happen if the outbreak were left to run its course, without public health interventions.

```{r SIR_model_plot_no_intervention, echo=FALSE, tidy=TRUE, message=FALSE, warning=FALSE}
# time in days for predictions - 100 days
t <- 1:100
# get the fitted values from our SIR model 1.846830e+05
fitted_cumulative_incidence <- data.frame(ode(y = init, times = t, 
                                              func = SIR, parms = Opt_par))
# add a Date column and join the observed incidence data
fitted_cumulative_incidence <- fitted_cumulative_incidence %>%
  mutate(Date = ymd(sir_start_date) + days(t-1),
         province="Peru_cases_increase") %>%
  mutate(I = round(I)) %>%
  left_join(Peru_Cumulative_Incidence %>% 
              ungroup() %>%
              filter(province=="Peru_cases_increase") %>%
              select(Date, cumulative_incident_cases)) %>%
  left_join(COVID_19_Peru_Raw %>%
              mutate(Deaths_Total = ifelse(is.na(Deaths_Total), 0, Deaths_Total)) %>%
              select(Date, Deaths_Total))
# plot the data
# h <- fitted_cumulative_incidence %>% 
#   mutate(Deaths = round(I*0.2)) %>%
#   ggplot(aes(x=Date)) + 
#   geom_line(aes(y=I), colour="red") +
#   geom_line(aes(y=S), colour="black") +
#   geom_line(aes(y=R), colour="green") +
#   geom_line(aes(y=Deaths), colour="brown") +
#   geom_point(aes(y=cumulative_incident_cases), colour="blue") +
#   scale_y_continuous(labels = scales::comma) +
#   labs(y="Persons", 
#        title="COVID-19 fitted vs observed cumulative incidence, Peru",
#        subtitle="(red = Infectious, black = Susceptible, green = Recovered, blue = Observed incidence") +
#   # scale_colour_manual(name = '', 
#   #                     values =c('orange' = 'orange', 'red'='red', 'black'='black', 'green'='green', 'blue'='blue'), 
#   #                     labels = c('Susceptible', 'Recovered', 'Observed incidence', 'Infectious')) +
#   theme_bw()
# 
# ggplotly(h)

plot_ly(type = "scatter", mode = "lines") %>%
  add_trace(x = ~Date, y = ~S,
            line = list(color = "black"),
            hoverinfo = "text",
            text = ~paste("Date: ", Date, "<br>",
                          "Susceptible Projected: ", round(S), "<br>"),
            showlegend = TRUE,
            name = "Susceptible Projected",
            data = fitted_cumulative_incidence ) %>%
  add_trace(x = ~Date, y = ~cumulative_incident_cases,
            mode = "marker",
            marker = list(color = "blue"),
            hoverinfo = "text",
            text = ~paste("Date: ", Date, "<br>",
                          "Symptomatic Cases Observed: ", cumulative_incident_cases, "<br>"),
            showlegend = TRUE,
            name = "Symptomatic Cases Observed",
            data = fitted_cumulative_incidence ) %>%
  add_trace(x = ~Date, y = ~Deaths_Total,
            mode = "marker",
            marker = list(color = "brown"),
            hoverinfo = "text",
            text = ~paste("Date: ", Date, "<br>",
                          "Deaths Observed: ", Deaths_Total, "<br>"),
            showlegend = TRUE,
            name = "Deaths Observed",
            data = fitted_cumulative_incidence ) %>%
  add_trace(x = ~Date, y = ~round(I),
            line = list(color = "red"),
            hoverinfo = "text",
            text = ~paste("Date: ", Date, "<br>",
                          "Sympomatic Cases Projected: ", round(I), "<br>"),
            showlegend = TRUE,
            name = "Symptomatic Cases Projected",
            data = fitted_cumulative_incidence ) %>%
  add_trace(x = ~Date, y = ~round(I*5),
            line = list(color = "green"),
            hoverinfo = "text",
            text = ~paste("Date: ", Date, "<br>",
                          "Total Cases Projected: ", round(I*5), "<br>"),
            showlegend = TRUE,
            name = "Total Cases Projected",
            data = fitted_cumulative_incidence ) %>%
  add_trace(x = ~Date, y = ~round(R),
            line = list(color = "orange"),
            hoverinfo = "text",
            text = ~paste("Date: ", Date, "<br>",
                          "Symptomatic Recovered Projected: ", round(R), "<br>"),
            showlegend = TRUE,
            name = "Symptomatic Recovered Projected",
            data = fitted_cumulative_incidence
            ) %>%
  layout(xaxis = list(title = ""),
         yaxis = list(title = "# Persons", 
                       tickformat=",d"),
         title="COVID-19 fitted vs observed possitive cases in Peru (molecular test model)" )
```

It is easier to see what is going on if we use a log scale:

```{r SIR_model_plot_no_intervention_log, echo=FALSE, tidy=TRUE, message=FALSE, warning=FALSE}
# plot the data


plot_ly(type = "scatter", mode = "lines") %>%
  add_trace(x = ~Date, y = ~S,
            line = list(color = "black"),
            hoverinfo = "text",
            text = ~paste("Date: ", Date, "<br>",
                          "Susceptible Projected: ", round(S), "<br>"),
            showlegend = TRUE,
            name = "Susceptible Projected",
            data = fitted_cumulative_incidence ) %>%
  add_trace(x = ~Date, y = ~cumulative_incident_cases,
            mode = "marker",
            marker = list(color = "blue"),
            hoverinfo = "text",
            text = ~paste("Date: ", Date, "<br>",
                          "Symptomatic Cases Observed: ", cumulative_incident_cases, "<br>"),
            showlegend = TRUE,
            name = "Symptomatic Cases Observed",
            data = fitted_cumulative_incidence ) %>%
  add_trace(x = ~Date, y = ~Deaths_Total,
            mode = "marker",
            marker = list(color = "brown"),
            hoverinfo = "text",
            text = ~paste("Date: ", Date, "<br>",
                          "Deaths Observed: ", Deaths_Total, "<br>"),
            showlegend = TRUE,
            name = "Deaths Observed",
            data = fitted_cumulative_incidence ) %>%
  add_trace(x = ~Date, y = ~round(I),
            line = list(color = "red"),
            hoverinfo = "text",
            text = ~paste("Date: ", Date, "<br>",
                          "Sympomatic Cases Projected: ", round(I), "<br>"),
            showlegend = TRUE,
            name = "Sympomatic Cases Projected",
            data = fitted_cumulative_incidence ) %>%
  add_trace(x = ~Date, y = ~round(I*5),
            line = list(color = "green"),
            hoverinfo = "text",
            text = ~paste("Date: ", Date, "<br>",
                          "Total Cases Projected: ", round(I*5), "<br>"),
            showlegend = TRUE,
            name = "Total Cases Projected",
            data = fitted_cumulative_incidence ) %>%
  add_trace(x = ~Date, y = ~round(R),
            line = list(color = "orange"),
            hoverinfo = "text",
            text = ~paste("Date: ", Date, "<br>",
                          "Symptomatic Recovered Projected: ", round(R), "<br>"),
            showlegend = TRUE,
            name = "Symptomatic Recovered Projected",
            data = fitted_cumulative_incidence
            ) %>%
  layout(xaxis = list(title = ""),
         yaxis = list(title = "Persons (log)", type = "log",
                       tickformat=",d"),
         title="COVID-19 fitted (log) vs observed possitive cases in Peru (molecular test model)" )

# fitted_cumulative_incidence %>%
#   mutate(Deaths = round(I*0.2)) %>%
#   ggplot(aes(x=Date)) + 
#   geom_line(aes(y=I, colour="red")) +
#   geom_line(aes(y=S, colour="black")) +
#   geom_line(aes(y=R, colour="green")) +
#   geom_line(aes(y=Deaths), colour="brown") +
#   geom_point(aes(y=cumulative_incident_cases, colour="blue")) +
#   scale_y_log10(labels = scales::comma) +
#   labs(y="Persons", 
#        title="COVID-19 fitted vs observed cumulative incidence, Peru") +
#   scale_colour_manual(name = '', 
#                       values =c('red' = 'red', 'black' = 'black', 'green' = 'green',
#                                 'brown' = 'brown', 'blue' = 'blue'), 
#                       labels = c('Susceptible', 'Observed incidence', 'Recovered', 'Infectious', 'Deaths')) +
#   theme_bw() + theme(legend.position = "right")

```

I's clear that, if outbreak follows model above, it would ended up quite bad due that Peruvian Health System is not design to support this pandemic. 

Additionally, we observe that model above, which is based on **molecular test results only**, differs from official peruvian numbers mainly due that **official numbers are a mix of serological and molecular test results which may lower accuracy on official numbers.**

At this point, it is worth remarking on the importance of decisive public health intervention to limit the spread of such epidemics. Without such interventions, tens of millions of people could be infected, as our model predicts, and even with only a one or two per cent mortality rate, hundreds of thousands of people would die. 

# Epidemic trajectory model using log-linear models

As noted above, the initial exponential phase of an outbreak, when shown in a semi-log plot (the y-axis with a logarithmic transform), looks somehow linear. This suggests that we may be able to model epidemic growth and decay using a simple log-linear model:

$$log(y) = rt + b$$

where $y$ is the incidence, $r$ is the growth rate, $t$ is the number of days since a specific point in time (typically the start of the outbreak), and $b$ is the intercept. Separate models are fitted to the growth and the decay parts of the epidemic (incidence data) curve.


```{r incidence_object, echo=FALSE, tidy=TRUE, message=FALSE}
# create a vector of dates, in character form
# using the uncount() function.
library(incidence)
Peru_incidence_function_data <- COVID_19_Peru_Raw %>%
  filter(Date <= ymd(Sys.Date())) %>%
  mutate(Peru_cases_increase  = ifelse(is.na(Peru_cases_increase ), 0, Peru_cases_increase )) %>%
  mutate(Date=format(Date, "%Y-%m-%d")) %>%
  select(Date, Peru_cases_increase) %>%
  uncount(Peru_cases_increase)

Peru_incidence_object <- incidence(Peru_incidence_function_data$Date)
```

I proceed to find the *peak* of confirmed possitive cases based on current available data.

```{r plot_incidence_object, echo=FALSE, tidy=TRUE, message=FALSE}
Peru_incidence_peak <- find_peak(Peru_incidence_object)

plot(Peru_incidence_object) + 
  geom_vline(xintercept = Peru_incidence_peak, col = "red", lty = 2) +
  labs(title="Daily number of lab-confirmed possitive cases in Peru",
       subtitle = "(red line indicates date of peak incidence)") +
  theme_bw()

```

Now I proceed to fit a log-linear model for the growth phase before the peak. I can plot the fitted values from our model (with confidence limits) on top of the actual observed possitive incidence data for Peru.

```{r fit_incidence_object, echo=FALSE, tidy=TRUE, message=FALSE, warning=FALSE, preview=TRUE}

# Due that the model doesn't show an statistical peak just yet
Peru_incidence_fit <- incidence::fit(Peru_incidence_object)

# Peru_incidence_fit <- incidence::fit(Peru_incidence_object,
#                                       split=Peru_incidence_peak)

# plot the incidence data and the model fit
plot(Peru_incidence_object) %>% 
  add_incidence_fit(Peru_incidence_fit) +
  labs(title="Daily number of lab-confirmed possitive cases in Peru",
       subtitle = "Observed VS Modeled") + 
  theme_bw()

```

And here I will evaluate **force-of-infection Î» plot**

```{r, echo=FALSE}
si_mean <- 5.0
si_sd <- 3.4
alt_si_mean <- 7.5
alt_si_sd <- 3.4
```

```{r, echo=FALSE, message=FALSE, warning=FALSE}

provincia <- "Peru_cases_increase"
last_date <- ymd(Sys.Date())

province_earlyR <- function(df, provincia, last_date, si_mean, si_sd) {
  Peru_Cumulative_Incidence %>%
  filter(Date <= last_date,
         !is.na(incident_cases),
         province == provincia) %>%
  select(Date, incident_cases) %>%
  uncount(incident_cases) %>%
  pull(Date) -> local_case_dates
  
  local_case_dates %>%
  incidence(., last_date=last_date) -> local_cases
  
  res <- get_R(local_cases, si_mean =si_mean, si_sd = si_sd)
  res$local_case_dates <- local_case_dates
  res$provincia <- provincia
  res$last_date <- last_date
  res$si_mean <- si_mean
  res$si_sd <- si_sd
  return(res)
}

province_plot_lambda <- function(res) {
  plot(res, "lambdas", scale = length(res$local_case_dates) + 1,
       bty="n")
  title(sub=paste("\nEstimated", expression(lambda), "for", 
                            res$provincia,  
                            "(assuming serial interval mean =",
                            res$si_mean, 
                            ", sd =", 
                            res$si_sd, ")"))
  abline(v = res$local_case_dates, lwd = 3, col = "grey")
  abline(v = res$last_date, col = "blue", lty = 2, lwd = 2)
  points(res$local_case_dates, seq_along(res$local_case_dates), pch = 20, cex = 3)
}

lambda_plot_Peru <- function(provincia) {
  res_obj <- province_earlyR(Peru_Cumulative_Incidence, 
                                provincia,
                                last_date,
                              si_mean,
                              si_sd)
  province_plot_lambda(res_obj)
}

lambda_plot_Peru(provincia)

```


```{r  incidence_object_refit_stats, echo=FALSE, tidy=TRUE, message=FALSE, warning=FALSE, layout="l-body-outset"}

growth_model_fit_stats <- glance(Peru_incidence_fit$model) %>%
                          mutate(Dates="all") %>%
                          select(Dates, r.squared, adj.r.squared, deviance)

end_date <- Sys.Date()

growth_model_fit_stats %>%
  gt() %>%
  tab_header(title = md("**Model Fitted Statistics**"),
             subtitle = glue::glue("Last update on: {end_date}")) %>%
  fmt_number(columns=2:4, decimals = 2) %>%
  cols_label(Dates = md("**Dates**"),
             r.squared = md("**R2**"),
             adj.r.squared = md("**Adj. R2**"),
             deviance = md("**Deviance**") )

```
<br>
From the model, we can extract various parameters of interest: the **growth rate prior to the peak was `r format(incidence::get_info(Peru_incidence_fit, "r")[1],digits=2,nsmall=2)`** (95% CI `r format(incidence::get_info(Peru_incidence_fit, "r.conf")[1,1],digits=2,nsmall=2)` - `r format(incidence::get_info(Peru_incidence_fit, "r.conf")[1,2],digits=2,nsmall=2)`).

This growth rates is equivalent to a **doubling time of `r format(incidence::get_info(Peru_incidence_fit, "doubling")[1],digits=1,nsmall=1)` days** (95% CI `r format(incidence::get_info(Peru_incidence_fit, "doubling.conf")[1],digits=1,nsmall=1)` - `r format(incidence::get_info(Peru_incidence_fit, "doubling.conf")[2],digits=1,nsmall=1)` days). 

The doubling time estimate is quite ilustrative on informing current public health intervention policy in Peru. 

**Assessment**: Outbreak in Peru is not in control yet and may still growth if public health policies are not followed.

## Estimating the reproduction number from log-linear models
<br>
Based on log-linear model of the epidemic trajectory I'm able to estimate the reproduction number in the growth phase of the epidemic. I need to provide a distribution for the _serial interval_ time, which is the time between the onset of a primary case and the time of onset in its secondary cases. I'll use a mean of 7.5 days and a standard deviation of 3.4 days to parameterise a discrete gamma distribution for the serial interval based on analysis of just 5 primary cases amongst the first 450 cases in Wuhan, published by [Li _et al._](https://www.nejm.org/doi/full/10.1056/NEJMoa2001316). Here is a histogram of our calculated distribution of possible values for $R_{0}$ for the growth phase, based on the log-linear model we fitted to the Peru incidence data:

```{r est_R0_growth, echo=TRUE, tidy=TRUE, message=FALSE, warning=FALSE}

mu <- 7.5 # days
sigma <- 3.4 # days
param <- gamma_mucv2shapescale(mu, sigma / mu)
w <- distcrete("gamma", interval = 1,
                 shape = param$shape,
                 scale = param$scale, w = 0)

growth_R0 <- lm2R0_sample(Peru_incidence_fit$model, w)
hist(growth_R0, col = "darkblue", border = "white", main = "R0 distribution in Peru")
summary(growth_R0)
```

Note that the central estimates for $R_{0}$ are considerably higher than those we calculated with a SIR model fitted to the same Peru data, and are also higher than $R_{0}$ estimates published elsewhere, but they are consistent with estimates of the instantaneous effective reproduction number $R_{e}$ which are calculated in the next section^[They are also consistent with unpublished estimates of $R_{0}$ for the COVID-19 virus being discussed in various expert in WHO.]. 

# Estimating changes in the _effective reproduction number_
<br>
It would be useful to estimate the current _effective reproduction number_ $R_{e}$ on a day-by-day basis so as to track the effectiveness of public health interventions in Peru, and possibly predict at the earliest opportunity when an outbreak will turn the corner.

There are several available methods for estimating $R_{e}$ -- . Here I will focus on one method, developed in 2013 by Anne Cori and colleagues at Imperial College, London, which permits estimation of the _instantaneous effective reproduction number_, which is exactly want we want in order to track the effectiveness of containment efforts. Full details are available in the [original paper](https://www.ncbi.nlm.nih.gov/pmc/articles/PMC3816335/) on the method, with extensions described in a later paper by [Thompson _et al._](https://doi.org/10.1016/j.epidem.2019.100356). 

Once again, I'll start with the counts of lab-confirmed posstive cases in Peru from 06th March 2020 onwards.

```{r Cori_model_get_data_Peru, echo=FALSE, tidy=TRUE, message=FALSE}
Peru_confirmed_cases <- COVID_19_Peru_Raw %>%
  mutate(Peru_Total_Cases = ifelse(is.na(Peru_Total_Cases), 
                                   0, Peru_Total_Cases)) %>%
  mutate(I = ifelse(Date == ymd("2020-03-01"), 0, Peru_Total_Cases)) %>%
#  mutate(imported = ifelse(Date == ymd("2020-03-01"), Peru_Total_Cases, 0)) %>%
  select(Date, I) %>%
  rename(dates=Date)
```

A critical parameter for the Cori model is the _serial interval_ (SI). The SI is the time between onset of symptoms of each case of the disease in question, and the onset of symptoms in any secondary cases that result from transmission from the primary cases. In other words, it is the time between cases in the (branching) chain of transmission of the disease. A moment's reflection reveals that the SI is, in fact, a statistical distribution of serial interval times, rather than a fixed value. That distribution can be simulated, typically using a discrete _gamma_ distribution with a given mean and standard deviation. 

There are different models that allows uncertainty to be incorporated into the parameterisation of this distribution, and it even allows the SI distribution to be estimated empirically, using Bayesian methods, from individual line-listings of cases. We'll examine all of those capabilities.

I'm currently using one published estimate of the _serial interval_ distribution, derived from analysis of just 5 primary cases amongst the first 450 cases in Wuhan, published by [Li _et al._](https://www.nejm.org/doi/full/10.1056/NEJMoa2001316). They estimate the serial interval distribution to have a mean of 7.5 days with a standard deviation of 3.4 days. This is almost identical to the  _serial interval_ parameters for the MERS virus, which were a mean of 7.6 and a SD of 3.4. This similarity is not surprising given that both pathogens are _coronavirii_. Let's use that to estimate the instantaneous $R_{e}$ for Peru.
<br>
```{r Cori_parametric_si_model_fit_Peru, echo=FALSE, tidy=TRUE, message=FALSE, warning=FALSE}

plot_Ri <- function(estimate_R_obj) {
  p_I <- plot(estimate_R_obj, "incid") # plots the incidence
  p_SI <- plot(estimate_R_obj, "SI") # plots the serial interval distribution
  p_Ri <- plot(estimate_R_obj, "R")
  return(gridExtra::grid.arrange(p_I, p_SI, p_Ri, ncol = 1))
}
# 
# tryCatch(
#   Peru_res_parametric_si <- estimate_R(Peru_confirmed_cases,
#                                      method="parametric_si",
#                                      config = make_config(list(
#                                        mean_si = 7.5, 
#                                        std_si = 3.4))),
#   tibble_error = function(cnd) {
#   }
# )

Peru_res_parametric_si <- estimate_R(Peru_confirmed_cases,
                                      method="parametric_si",
                                      config = make_config(list(
                                        mean_si = 7.5, std_mean_si = 2.0,
                                        min_mean_si = 1, max_mean_si = 8.4,
                                        std_si = 3.4, std_std_si = 1.0,
                                        min_std_si = 0.5, max_std_si = 4.0,
                                        n1 = 1000, n2 = 1000)))

plot_Ri(Peru_res_parametric_si)

```
<br>
The first thing to note is that the slope of the _effective reproduction number_ curve have yet to show a prominent downward shift, which strongly suggests that containment efforts are yet to succeed in reducing transmission of the disease in Peru.

The second thing to note is that the 7-day sliding window estimates of **instantaneous** $R_{e}$ are very high, approaching 15 at the peak. This seems unlikely. It is possible that the Cori model is flawed but has been shown to accurately estimate $R_{e}$ using a wide range of historical outbreak data. There are, however, a number of possible alternative explanations. 

One possible explanation is that COVID-19 is transmissible **before** the onset of symptoms, resulting in much shorter serial intervals than expected, possibly shorter than the incubation period. Alternatively, and very likely, there may be non-symptomatic, sub-clinical spreaders of the disease, who are undetected. Again, the effect is as if the serial interval is very short, although it would be desirable to explicitly model that scenario, but current methods don't permit that. 

To cover the possibility of some cases transmitting the disease very soon after infection, possibly before the onset of symptoms (so-called _super-spreaders_), and some cases being sub-clinical, and thus undetected, spreading the disease as well, while other cases have a serial interval more consistent with that of MERS or SARS, with a mean around 8 days, I proceed to incorporate this uncertainty around the serial interval distribution by allowing specification of a distribution of distributions of serial intervals. So let's retain the mean SI estimated by Li _et al._ of 7.5 days, with an SD of 3.4, but let's also allow that mean SI to vary between 2.3 and 8.4 using a truncated normal distribution with an SD of 2.0. We'll also allow the SD or the SI to vary between 0.5 and 4.0. 

Recalculating with those SI distribution parameters and meta-parameters, we get these results:

<br>
```{r Cori_uncertain_si_model_fit_Peru, echo=FALSE, tidy=TRUE, message=FALSE, warning=FALSE}

Peru_res_parametric_si <- estimate_R(Peru_confirmed_cases,
                                method="uncertain_si",
                                config = make_config(list(
                                  mean_si = 7.5, std_mean_si = 2.0,
                                  min_mean_si = 1, max_mean_si = 8.4,
                                  std_si = 3.4, std_std_si = 1.0,
                                  min_std_si = 0.5, max_std_si = 4.0,
                                  n1 = 1000, n2 = 1000)))
plot_Ri(Peru_res_parametric_si)
```

<br>
Analysis above looks more reasonable, and clearly the $R_{e}$ is not falling just yet in Peru.

Let's use data above to re-estimate $R_{e}$. Bayesian methods are used, and the trace output below is from the MCMC (Markov-chain Monte Carlo) resampling methods used.
<br>
```{r Cori_empirical_si_model_fit_Peru_daily, echo=FALSE, tidy=TRUE, message=FALSE, warning=FALSE}
SL=c(5,9,7,3,7,8,1,3,7,9,12)


si_data_wuhan_Li <- data.frame(EL=as.integer(rep(0,11)),
                               ER=as.integer(rep(1,11)),
                               SL=as.integer(SL),
                               SR=as.integer(SL+1))
## fixing the random seeds
MCMC_seed <- 1
overall_seed <- 2
mcmc_control <- make_mcmc_control(seed = MCMC_seed, 
                                  burnin = 1000)
dist <- "G" # fitting a Gamma distribution for the SI
# empirical_si_config <- make_config(list(si_parametric_distr = dist,
#                                         mcmc_control = mcmc_control,
#                                         seed = overall_seed, 
#                                         n1 = 50, 
#                                         n2 = 50))

empirical_si_config <- make_config(list(mean_si = 7.5, std_mean_si = 2.0,
                                       min_mean_si = 1, max_mean_si = 8.4,
                                       std_si = 3.4, std_std_si = 1.0,
                                       min_std_si = 0.5, max_std_si = 4.0,
                                       n1 = 1000, n2 = 1000))


Peru_res_empirical_si <- estimate_R(Peru_confirmed_cases,
                                    method = "uncertain_si",
                                    # si_data = si_data_wuhan_Li,
                                    config = empirical_si_config)

plot_Ri(Peru_res_empirical_si)
```

That is remarkably similar to our estimates based on an "uncertain" meta-distribution for the _serial interval_, above, which is encouraging.

Nonetheless some of the $R_{e}$ values are still rather high. Remember, these are **instantaneous** _reproductive numbers_, averaged over a sliding 7-day window. Let's change that to a shorter window to see what the day-to-day changes in $R_{e}$ are, rather than based on an aggregation of the preceding 7-days. I'll plot the results using a logarithmic scale with a red reference line at 1.0, representing the _reproduction number_ below which the outbreak will start to die out.

```{r Cori_uncertain_si_model_fit_Peru_daily, echo=FALSE, tidy=TRUE, message=FALSE, warning=FALSE}

t_start <- seq(2, length(Peru_confirmed_cases$I)-1)   
t_end <- t_start + 1             

empirical_si_config_daily <- make_config(list(si_parametric_distr = dist,
                                              mcmc_control = mcmc_control,
                                              seed = overall_seed, 
                                              n1 = 50, 
                                              n2 = 50,
                                              t_start = t_start,
                                              t_end = t_end))

empirical_si_config_daily <- make_config(list(mean_si = 7.5, std_mean_si = 2.0,
                                       min_mean_si = 1, max_mean_si = 8.4,
                                       std_si = 3.4, std_std_si = 1.0,
                                       min_std_si = 0.5, max_std_si = 4.0,
                                       n1 = 1000, n2 = 1000))


Peru_res_uncertain_si_daily <- estimate_R(Peru_confirmed_cases,
                                          method = "uncertain_si",
                                          # si_data = si_data_wuhan_Li,
                                          config = empirical_si_config_daily)

# plot_Ri(Peru_res_uncertain_si_daily)
plot(Peru_res_uncertain_si_daily, "R") +
  scale_y_continuous(trans='log2') +
  geom_hline(yintercept=1.0, linetype="solid", colour='red', size=0.5)
```

So, it looks like the outbreak has yet to been brought under control in Peru, at least based on the published lab-confirmed possitive case numbers and the available serial interval data or estimates of its distribution.

It is clear that control measures have yet to work by looking at the daily incremental incidence numbers for Peru:

```{r Peru_daily_incidence_adj, echo=FALSE, tidy=TRUE, message=FALSE, warning=FALSE}

k <- COVID_19_Peru_Raw %>%
  ggplot(aes(x=Date, 
             y=Peru_Total_Cases)) +
  geom_point() +
  geom_line() +
  labs(y="Daily incremental incidence",
       title="Peru lab-confirmed possitive cases") + 
  theme_bw()

ggplotly(k)
```

## Using other models to understand outbreak in Peru
<br>
Here I will use a different approach such as linear and GLM regressions to fit COVID-19 outbreak in Peru:

```{r GLM Linear Model, echo=FALSE, fig.height=13}

## Summary of COVID-19 Outbreak Peru

tots.per.location(tsc, geo.loc = "Peru")

```

```{r, echo=FALSE}
totals.plt(tsa, c('Peru'))
```


Here we can see the growth rate in Peru:

```{r growth, echo=FALSE, results = 'hide', fig.height=10}
growth.rate(tsc, geo.loc = "Peru")
```

Finally, here we can observe daily trends based on current official data

```{r, echo=FALSE}

mtrends(tsc, geo.loc=c("Peru"))

```

# Projections 
<br>
After creating projections based on a simple SIR model, it is possible to use a more complex model to generate a sophisticated projection as well. 

Here below I created a projection based up to `r format(get_dates(Peru_incidence_object)[(length(get_dates(Peru_incidence_object)) - 5)], "%d %B %Y")` data. Projection extends up to 14 days from last observed possitive case.

```{r test_projection_Peru_growth, echo=FALSE, tidy=TRUE, message=FALSE, warning=FALSE}

pred_fwd_days <- 25
date_range <- 1:(which(get_dates(Peru_incidence_object) == Peru_incidence_peak) - pred_fwd_days)
# date_range <- 1: (nrow(COVID_19_Peru_Raw)-pred_fwd_days)

test_pred_growth <- projections::project(Peru_incidence_object[date_range],
                                         R = mean(growth_R0),
                                         si = w,
                                         n_days = pred_fwd_days+15, n_sim = 1000)

# convert the test_pred_growth matrix to a data frame and get the median
# incidence for all the simulations for each date
test_pred_growth_median_counts <- test_pred_growth %>%
  as.data.frame() %>%
  pivot_longer(-dates,
               names_to="simulation",
               values_to="incidence") %>%
  group_by(dates) %>%
  summarise(incident_cases=as.integer(median(incidence))) %>%
  mutate(data_type = "projection")

l <- test_pred_growth_median_counts %>%
  bind_rows(tibble(dates=get_dates(Peru_incidence_object),
                   incident_cases=get_counts(Peru_incidence_object),
                   data_type="observed")) %>%
  ggplot(aes(x=dates, y=incident_cases, colour=data_type)) +
    geom_point() +
    geom_line() +
    labs(x="", y="Daily incident confirmed cases",
         title="Observed versus growth-phase projection of incident cases in Peru") +
         theme(legend.position="top", legend.title = element_blank()) +
  theme_bw()

ggplotly(l)
```
<br>
Based on that projection, it will take until May for the outbreak in Peru to be extinguished.
